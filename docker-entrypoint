#!/usr/bin/env bash
set -e

DOCKER_SOCK=/var/run/docker.sock
CRONTAB_FILE=/etc/crontabs/docker

# For local testing only.
#HOME_DIR=.

if [ -z "${HOME_DIR}" ]; then
    echo "HOME_DIR not set."
    exit 1
fi

# Ensure dir exist - in case of volume mapping.
mkdir -p "${HOME_DIR}"/jobs "${HOME_DIR}"/projects

if [ -z "${DOCKER_HOST}" ] && [ -a "${DOCKER_PORT_2375_TCP}" ]; then
    export DOCKER_HOST="tcp://docker:2375"
fi

if [ "${LOG_FILE}" == "" ]; then
    LOG_DIR=/var/log/crontab
    LOG_FILE=${LOG_DIR}/jobs.log
    mkdir -p ${LOG_DIR}
    touch ${LOG_FILE}
fi

normalize_config() {
    JSON_CONFIG={}
    if [ -f "${HOME_DIR}/config.json" ]; then
        JSON_CONFIG="$(cat "${HOME_DIR}"/config.json)"
    elif [ -f "${HOME_DIR}/config.toml" ]; then
        JSON_CONFIG="$(rq -t <<< "$(cat "${HOME_DIR}"/config.toml)")"
    elif [ -f "${HOME_DIR}/config.yml" ]; then
        JSON_CONFIG="$(rq -y <<< "$(cat "${HOME_DIR}"/config.yml)")"
    elif [ -f "${HOME_DIR}/config.yaml" ]; then
        JSON_CONFIG="$(rq -y <<< "$(cat "${HOME_DIR}"/config.yaml)")"
    fi
    jq -r 'map(.)' <<< "${JSON_CONFIG}" > "${HOME_DIR}"/config.working.json
}

ensure_docker_socket_accessible() {
    if ! grep -q "^docker:" /etc/group; then
        # Ensure 'docker' user has permissions for docker socket (without changing permissions).
        DOCKER_GID=$(stat -c '%g' ${DOCKER_SOCK})
        if [ "${DOCKER_GID}" != "0" ]; then
            if ! grep -qE "^[^:]+:[^:]+:${DOCKER_GID}:" /etc/group; then
                # No group with such gid exists - create group docker.
                addgroup -g "${DOCKER_GID}" docker
                adduser docker docker
            else
                # Group with such gid exists - add user "docker" to this group.
                DOCKER_GROUP_NAME=$(getent group "${DOCKER_GID}" | awk -F':' '{{ print $1 }}')
                adduser docker "${DOCKER_GROUP_NAME}"
            fi
        else
            # Docker socket belongs to "root" group - add user "docker" to this group.
            adduser docker root
        fi
    fi
}

slugify() {
    echo "${@}" | iconv -t ascii | sed -r s/[~^]+//g | sed -r s/[^a-zA-Z0-9]+/-/g | sed -r s/^-+\|-+$//g | tr '[:upper:]' '[:lower:]'
}

make_image_cmd() {
    DOCKERARGS=$(echo "${1}" | jq -r .dockerargs)
    if [ "${DOCKERARGS}" == "null" ]; then DOCKERARGS=; fi
    VOLUMES=$(echo "${1}" | jq -r 'select(.volumes != null) | .volumes | map(" -v " + .) | join("")')
    PORTS=$(echo "${1}" | jq -r 'select(.ports != null) | .ports | map(" -p " + .) | join("")')
    EXPOSE=$(echo "${1}" | jq -r 'select(.expose != null) | .expose | map(" --expose " + .) | join("")')
    NAME=$(echo "${1}" | jq -r 'select(.name != null) | .name')
    NETWORK=$(echo "${1}" | jq -r 'select(.network != null) | .network')
    ENVIRONMENT=$(echo "${1}" | jq -r 'select(.environment != null) | .environment | map(" -e " + .) | join("")')
    if [ -n "${NAME}" ]; then DOCKERARGS+=" --rm --name ${NAME} "; fi
    if [ -n "${NETWORK}" ]; then DOCKERARGS+=" --network ${NETWORK} "; fi
    if [ -n "${VOLUMES}" ]; then DOCKERARGS+="${VOLUMES}"; fi
    if [ -n "${ENVIRONMENT}" ]; then DOCKERARGS+="${ENVIRONMENT}"; fi
    if [ -n "${PORTS}" ]; then DOCKERARGS+="${PORTS}"; fi
    if [ -n "${EXPOSE}" ]; then DOCKERARGS+="${EXPOSE}"; fi
    IMAGE=$(echo "${1}" | jq -r .image | envsubst)
    TMP_COMMAND=$(echo "${1}" | jq -r .command)
    echo "docker run ${DOCKERARGS} ${IMAGE} ${TMP_COMMAND}"
}

make_container_cmd() {
    DOCKERARGS=$(echo "${1}" | jq -r .dockerargs)
    if [ "${DOCKERARGS}" == "null" ]; then DOCKERARGS=; fi
    SCRIPT_NAME=$(echo "${1}" | jq -r .name)
    SCRIPT_NAME=$(slugify "${SCRIPT_NAME}")
    PROJECT=$(echo "${1}" | jq -r .project)
    CONTAINER=$(echo "${1}" | jq -r .container | envsubst)
    TMP_COMMAND=$(echo "${1}" | jq -r .command)

    if [ "${PROJECT}" != "null" ]; then
        # Create bash script to detect all running containers.
        if [ "${SCRIPT_NAME}" == "null" ]; then
            SCRIPT_NAME=$(cat /proc/sys/kernel/random/uuid)
        fi
cat << EOF > "${HOME_DIR}"/projects/"${SCRIPT_NAME}".sh
#!/usr/bin/env bash
set -e

CONTAINERS=\$(docker ps --format '{{.Names}}' | grep -E "^${PROJECT}_${CONTAINER}.[0-9]+")
for CONTAINER_NAME in \${CONTAINERS}; do
    docker exec "${DOCKERARGS} \${CONTAINER_NAME} ${TMP_COMMAND}"
done
EOF
        echo "/bin/bash ${HOME_DIR}/projects/${SCRIPT_NAME}.sh"
    else
        echo "docker exec ${DOCKERARGS} ${CONTAINER} ${TMP_COMMAND}"
    fi
}

#make_host_cmd() {
#   HOST_BINARY=$(echo ${1} | jq -r .host)
#   TMP_COMMAND=$(echo ${1} | jq -r .command)
#   echo "${HOST_BINARY} ${TMP_COMMAND}"
#}

make_cmd() {
    if [ "$(echo "${1}" | jq -r .image)" != "null" ]; then
        make_image_cmd "${1}"
    elif [ "$(echo "${1}" | jq -r .container)" != "null" ]; then
        make_container_cmd "${1}"
    #elif [ "$(echo ${1} | jq -r .host)" != "null" ]; then
    #   make_host_cmd "${1}"
    else
        echo "${1}" | jq -r .command
    fi
}

parse_schedule() {
    case $1 in
        "@yearly")
            echo "0 0 1 1 *"
            ;;
        "@annually")
            echo "0 0 1 1 *"
            ;;
        "@monthly")
            echo "0 0 1 * *"
            ;;
        "@weekly")
            echo "0 0 * * 0"
            ;;
        "@daily")
            echo "0 0 * * *"
            ;;
        "@midnight")
            echo "0 0 * * *"
            ;;
        "@hourly")
            echo "0 * * * *"
            ;;
        "@every")
            TIME=$2
            TOTAL=0

            M=$(echo "${TIME}" | grep -o '[0-9]\+m')
            H=$(echo "${TIME}" | grep -o '[0-9]\+h')
            D=$(echo "${TIME}" | grep -o '[0-9]\+d')

            if [ -n "${M}" ]; then
                TOTAL=$((TOTAL + ${M::-1}))
            fi
            if [ -n "${H}" ]; then
                TOTAL=$((TOTAL + ${H::-1} * 60))
            fi
            if [ -n "${D}" ]; then
                TOTAL=$((TOTAL + ${D::-1} * 60 * 24))
            fi

            echo "*/${TOTAL} * * * *"
            ;;
        *)
            echo "${@}"
            ;;
    esac
}

function build_crontab() {
    rm -rf ${CRONTAB_FILE}

    ONSTART=()
    while read -r i ; do
        SCHEDULE=$(jq -r .["$i"].schedule "${CONFIG}" | sed 's/\*/\\*/g')
        if [ "${SCHEDULE}" == "null" ]; then
            echo "'schedule' missing: $(jq -r .["$i"].schedule "${CONFIG}")"
            continue
        fi
        SCHEDULE=$(parse_schedule "${SCHEDULE}" | sed 's/\\//g')

        COMMAND=$(jq -r .["$i"].command "${CONFIG}")
        if [ "${COMMAND}" == "null" ]; then
            echo "'command' missing: '${COMMAND}'"
            continue
        fi

        COMMENT=$(jq -r .["$i"].comment "${CONFIG}")
        if [ "${COMMENT}" != "null" ]; then
            COMMENT=" ${COMMENT}"
            echo "#${COMMENT}" >> ${CRONTAB_FILE}
        else
            # Reset COMMENT to empty rather than keep the 'null' value.
            COMMENT=" "
        fi

        SCRIPT_NAME=$(jq -r .["$i"].name "${CONFIG}")
        SCRIPT_NAME=$(slugify "${SCRIPT_NAME}")
        if [ "${SCRIPT_NAME}" == "null" ]; then
            SCRIPT_NAME=$(cat /proc/sys/kernel/random/uuid)
        fi

        COMMAND="/bin/bash ${HOME_DIR}/jobs/${SCRIPT_NAME}.sh"
cat << EOF > "${HOME_DIR}"/jobs/"${SCRIPT_NAME}".sh
#!/usr/bin/env bash
set -e

echo "start cron job **${SCRIPT_NAME}**${COMMENT}"
$(make_cmd "$(jq -c .["$i"] "${CONFIG}")")
EOF
        TRIGGER=$(jq -r .["$i"].trigger "${CONFIG}")
        if [ "${TRIGGER}" != "null" ]; then
            while read -r j ; do
                TRIGGER_COMMAND=$(jq .["$i"].trigger["$j"].command "${CONFIG}")
                if [ "${TRIGGER_COMMAND}" == "null" ]; then
                    echo "'command' missing: '${TRIGGER_COMMAND}'"
                    continue
                fi
                make_cmd "${TRIGGER_COMMAND}" >> "${HOME_DIR}"/jobs/"${SCRIPT_NAME}".sh
            done < <(jq -r '.['"$i"'].trigger|keys[]' "${CONFIG}")
        fi

        echo "echo \"end cron job **${SCRIPT_NAME}**${COMMENT}\"" >> "${HOME_DIR}"/jobs/"${SCRIPT_NAME}".sh

        echo "${SCHEDULE} ${COMMAND}" >> ${CRONTAB_FILE}

        if [ "$(jq -r .["$i"].onstart "${CONFIG}")" == "true" ]; then
            ONSTART+=("${COMMAND}")
        fi
    done < <(jq -r '.|keys[]' "${CONFIG}")

    echo "##### crontab generation complete #####"
    cat ${CRONTAB_FILE}

    echo "##### run commands with onstart #####"
    for COMMAND in "${ONSTART[@]}"; do
        echo "${COMMAND}"
        ${COMMAND} &
    done
}

start_app() {
    normalize_config
    export CONFIG=${HOME_DIR}/config.working.json
    if [ ! -f "${CONFIG}" ]; then
        echo "generated ${CONFIG} missing."
        exit 1
    fi
    if [ "${1}" == "crond" ]; then
        build_crontab
    fi
    echo "${@}"
    exec "${@}"
}

ensure_docker_socket_accessible
start_app "${@}"
